# Chapter 14 — Performance and Limitations

## 14.1 Overview

Mini Lisp prioritizes clarity and correctness over raw speed. Nevertheless, understanding performance characteristics and limitations is key for extending the interpreter.

## 14.2 Complexity of Core Operations

* **Symbol lookup**: O(depth of environment chain). No indexing beyond hash table lookup per frame.
* **List operations**: O(n) for length, append, mapping.
* **Macro expansion**: Each expansion step traverses the syntax tree; complexity proportional to form size.
* **Function application**: Creates a new environment frame and binds arguments linearly.

## 14.3 Macro Expansion Depth

* Maximum: 128 iterations.
* Prevents infinite recursive expansion.
* Configurable by changing constant in `eval.c`.

## 14.4 Memory Usage

* No garbage collection; memory usage grows with allocations.
* Interned symbols and builtins persist for process lifetime.
* Temporary lists or expansions may remain allocated longer than necessary.

## 14.5 Known Limitations

* **No tail-call optimization**: Recursive programs may cause stack overflow.
* **No garbage collector**: Long REPL sessions may leak memory.
* **Limited error recovery**: Errors print messages but do not propagate as exceptions.
* **Hygiene model**: Uses marking rather than full alpha-renaming. Works for `syntax-rules` but not general procedural macros.

## 14.6 Optimization Opportunities

* **Environments**: Optimize lookup with flat symbol tables or dictionary caching.
* **Macro expansion**: Memoize results for repeated forms.
* **Garbage collection**: Add mark-and-sweep to reclaim unused values.
* **Native compilation**: Extend evaluator to bytecode or JIT for speed.

## 14.7 Practical Performance

* Adequate for small scripts and teaching examples.
* Unsuitable for large-scale or performance-critical Lisp applications without further optimization.

---

Next chapter: **Extensibility Guide** — how to add built-ins, types, and forms.
