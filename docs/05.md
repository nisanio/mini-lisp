# Chapter 5 — Evaluator (`eval.[ch]`)

## 5.1 Overview

The evaluator is the **heart of Mini Lisp**. It recursively interprets expressions, integrates macro expansion, and dispatches on special forms.

## 5.2 Evaluation Algorithm

At a high level:

1. **Macro Expansion Phase**

   * Input expression wrapped as a syntax object.
   * Expanded using `macroexpand1_hygienic` repeatedly (up to 128 iterations).
   * If expansion transforms expression into a non-list (e.g., `(and)` → `#t`), evaluator re-dispatches on the result.
2. **Special Form Dispatch**

   * If expression is a pair, check whether its head is a recognized special form.
   * Otherwise, evaluate as a function application.
3. **Application**

   * Evaluate operator and operands.
   * Apply builtin or closure.
   * Error if operator is not callable.

## 5.3 Special Forms

* **Quote**: `(quote x)` → return `x` unevaluated.
* **If**: `(if test conseq [alt])`

  * Evaluates `test`; if true, evaluates `conseq`; else `alt` or `nil`.
  * Patched to accept at least 2 arguments, ignore extras beyond 3.
* **Begin**: `(begin expr1 expr2 …)` → evaluates sequence, returns last value.
* **Lambda**: `(lambda (params) body)` → creates closure with lexical environment.
* **Define**: `(define name expr)` → evaluates `expr` and binds in current env.
* **Set!**: `(set! name expr)` → mutates existing binding.
* **Let / Let**\*: Create new frames with sequential (`let*`) or parallel (`let`) bindings.
* **Define-syntax**: `(define-syntax name (syntax-rules ...))` → registers macro transformer.

## 5.4 Application of Functions

* **Builtins**: Call the underlying C function pointer.
* **Closures**: Create a new environment extended from closure’s env with arguments bound to parameters, then evaluate body.
* **Arity errors**: Checked explicitly; errors reported if wrong number of arguments.

## 5.5 Macro Expansion Integration

* `eval` contains a loop performing macroexpansion before dispatch.
* Uses `macroexpand1_hygienic` and checks macro registry.
* Re-dispatch mechanism ensures macros that collapse to atoms or constants are handled correctly.

## 5.6 Error Handling

* On invalid forms or runtime issues, evaluator calls `make_error`, printing to stderr and returning `nil`.
* Common errors:

  * Applying non-callable objects.
  * Unbound variables.
  * Wrong number of arguments to special forms or builtins.

## 5.7 Control Flow

* Evaluation is depth-first, recursive.
* No tail-call optimization currently implemented.
* Maximum macro expansion depth: 128.

---

Next chapter: **Syntax Objects (`syntax.[ch]`)**, foundation of hygienic macros.
