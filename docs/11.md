# Chapter 11 — Error Handling and Diagnostics

## 11.1 Overview

Mini Lisp reports errors consistently to **stderr** while continuing execution by returning `nil`. This lightweight strategy allows interactive use in the REPL without aborting the session.

## 11.2 Error Types

* **Syntax errors**: Detected by the reader or macro expander.
* **Unbound symbols**: Referencing a symbol not present in the environment.
* **Arity errors**: Incorrect number of arguments to special forms or built-ins.
* **Type errors**: Applying operations to unsupported types (e.g., arithmetic on strings).
* **Invalid macro definitions**: Malformed `syntax-rules` specifications.
* **Non-callable application**: Attempting to call a non-function value.

## 11.3 Error Reporting

* Implemented via `make_error(...)` which:

  * Prints `error: <message>` to stderr.
  * Returns `nil` to the evaluator.
* Messages are human-readable and consistent across modules.

## 11.4 Examples of Errors

```lisp
> (car 42)
error: car: argument is not a pair
nil

> (define-syntax bad (syntax-rules))
error: define-syntax: invalid syntax-rules specification
nil

> (broken 10)
error: unbound symbol: broken
nil
```

## 11.5 Test Coverage

* **`tests/05_errors.lisp`** validates error behavior:

  * Invalid macro definitions.
  * Unbound symbol references.
  * Non-callable applications.
* Ensures that error messages are triggered and runtime continues without crash.

## 11.6 Exit Codes

* By default, interpreter exits with status `0` even after errors.
* Option: modify `main.c` to propagate an error flag and return nonzero exit status for stricter scripting environments.

## 11.7 Diagnostics and Debugging Tools

* Built-ins `macroexpand` and `macroexpand-1` aid macro debugging.
* `print` vs `write` distinguish human-friendly vs escaped representations.
* REPL displays results immediately, helping detect incorrect expansions or evaluation paths.

---

Next chapter: **Build, Portability, and CI** — Makefile structure, portability notes, and compiler considerations.
