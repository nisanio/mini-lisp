# Chapter 6 — Syntax Objects (`syntax.[ch]`)

## 6.1 Overview

Syntax objects provide the data model for **hygienic macros**. Each syntax node pairs a raw datum (the Lisp value) with a set of **scope marks** that encode introduction and use sites. This enables reliable identifier resolution across macro boundaries without accidental capture.

## 6.2 Data Model

* **`Syntax`**: structure with

  * `Value* datum` — underlying Lisp value (symbols, pairs, literals).
  * `scope_set` — an immutable set of `scope_id` marks.
* **`scope_id`**: small integer generated by `fresh_scope()`.
* **Scope operations**:

  * `scope_union(a, b)` — combines two scope sets.
  * `syn_map_add_scope(s, id)` — returns a deep copy of `s` with `id` added to every symbol position in `datum`.

## 6.3 Construction and Utilities

* `syn_new(Value* datum)` — wraps a `Value*` into a `Syntax*` (initially empty scope set).
* `syn_clone(Syntax* s)` — deep copy.
* `syn_free(Syntax* s)` — releases memory.
* `is_symbol_named(Value* v, const char* name)` — utility for quick symbol checks by name.

## 6.4 Scope Semantics

* **Use-site scope**: A unique `scope_id` attached to the whole macro call; it marks references introduced by the caller.
* **Introduction scope**: A unique `scope_id` added to the expansion result; it marks bindings introduced by the macro.
* **Identifier comparators** consider both the symbol name and its scope set, preventing unintended capture.

## 6.5 Traversal and Mapping

`syntax.c` exposes mappers that walk the `datum` tree and apply transformations:

* Add/remove scope marks.
* Rebuild lists (`VAL_PAIR`) with updated children.
* Preserve non-symbol literals (numbers, booleans, strings) unchanged.

## 6.6 Integration Points

* **Macro expansion** (`macros.c`):

  * Before expansion, the macro call is marked with a **use-site scope**.
  * After expansion, the result is marked with an **introduction scope**.
* **Evaluator** (`eval.c`):

  * Wraps `Value*` as `Syntax*` for expansion steps.
  * Falls back to raw values once expansion completes.

## 6.7 Invariants

* Scope sets are immutable and reference-transparent.
* Adding a scope never mutates the original syntax node; it returns a new tree.
* Datum identity is preserved where no scope changes are required.

---

Next chapter: **Macro System (`macros.[ch]`)** — pattern matching (`syntax-rules`), rulesets, and template reification with ellipses.
