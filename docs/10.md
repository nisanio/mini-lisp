# Chapter 10 — Memory Management

## 10.1 Overview

Mini Lisp is implemented in C and manages memory manually. There is no garbage collector. Instead, allocation, ownership, and cleanup are handled by conventions within each module.

## 10.2 Allocation

* All `Value` objects are heap-allocated via constructors in `value.c`.
* Strings are duplicated with `xstrdup`, a portable replacement for `strdup`.
* Composite objects (pairs, vectors, hash tables, closures) allocate additional structures as needed.

## 10.3 Ownership

* **Values**: Owned by the environment or enclosing composite structure.
* **Environments**: Own the values they bind but may reference values allocated elsewhere.
* **Closures**: Capture references to environment frames.
* **Symbols**: Interned globally; managed in a global table.

## 10.4 Lifetimes

* Values persist until explicitly freed when clearing environments or global registries.
* Many objects are effectively permanent for the duration of the process (e.g., interned symbols, builtins).
* Temporary values (intermediate lists, macro expansions) are freed after use if not retained by the evaluator.

## 10.5 Error Handling

* On allocation failure, Mini Lisp prints `OOM` to stderr and terminates.
* There is no recovery strategy for out-of-memory conditions.

## 10.6 Portability Considerations

* `xstrdup` is defined because `strdup` is not standard C.
* Code adheres to C11 for portability across compilers.
* Attributes like `__attribute__((unused))` are used conditionally to silence warnings.

## 10.7 Future Extensions

* **Garbage Collection**: Adding mark-and-sweep or reference counting could allow long-running sessions without leaks.
* **Arena Allocator**: Using region-based allocation per REPL session for faster bulk deallocation.
* **Weak Tables**: For caching symbols or macro expansions.

---

Next chapter: **Error Handling and Diagnostics** — types of errors, reporting strategy, and test coverage.
