# Chapter 7 — Macro System (`macros.[ch]`)

## 7.1 Overview

The macro system implements **hygienic `syntax-rules`** over the `Syntax` layer. It supports single-step expansion (`macroexpand-1`) and iterative expansion (`macroexpand`) with scope marking for use-site and introduction.

## 7.2 Core Types

* **`SRRule`** — a single `(pattern, template)` pair.
* **`SRRuleset`** — an ordered collection of rules.
* **`SyntaxTransformer`** — a transformer holding an `SRRuleset` and metadata.

## 7.3 Registry

* **Global registry** maps macro names → `SyntaxTransformer`.

  * `int  macro_define(const char* name, SyntaxTransformer* tr)` — registers a macro (takes ownership).
  * `const SyntaxTransformer* macro_lookup(const char* name)` — fetches transformer.
  * `void macro_registry_clear(void)` — releases all entries.

## 7.4 Expansion API

* **Single step (hygienic)**: `Syntax* macroexpand1_hygienic(Env* env, const Syntax* form)`

  * Adds **use-site scope** to the call.
  * Attempts matching and template reification via `sr_expand_call`.
  * Adds **introduction scope** to the result.
  * Returns `NULL` if the form is not a macro call or no rule matched.
* **Iterative**: The built-in `macroexpand` loops `macroexpand1_hygienic` up to 128 steps.

## 7.5 Pattern Matching (`syntax-rules`)

* Patterns are lists whose head is the macro name; variables are **symbols** used as binders.
* Matching produces a `Bindings` structure mapping pattern variables → lists of matched datums (to support ellipses).
* **Literals** are symbols that must match exactly (by name and scope, as applicable).

## 7.6 Ellipses (`...`)

* A pattern subform `(var ...)` matches **zero or more** occurrences.
* Bindings remember **all** matches per variable; templates can splice them back.

## 7.7 Template Reification

* `reify_node` / `reify_list` reconstruct the output datum from the template and `Bindings`.
* Splicing: occurrences of `(var ...)` inside templates are expanded by iterating over bound sequences.
* **Free identifiers** (symbols not bound by the pattern) are emitted **as-is** from the template’s datum; their scopes are then augmented by the **introduction scope**.

## 7.8 Hygiene via Scopes

* **Use-site scope** applied to the call ensures references coming from the caller remain distinct.
* **Introduction scope** on the result marks identifiers introduced by the macro, preventing accidental capture.
* Symbol comparison in later phases considers both name and scope set.

## 7.9 Evaluator Integration

* `eval` attempts macro expansion **before** analyzing special forms:

  1. Try `macroexpand1_hygienic`.
  2. If no expansion but operator is a macro, try `sr_expand_call` directly.
  3. **Re-dispatch** if the result is no longer a pair (e.g., macro collapses to an atom).
* Depth limit: 128 expansions to avoid infinite loops.

## 7.10 Errors and Diagnostics

* Invalid `syntax-rules` forms trigger `error: define-syntax: invalid syntax-rules specification`.
* Non-call macro forms or unmatched rules return `NULL` (no expansion).
* `macroexpand` and `macroexpand-1` are exposed as built-ins for inspection.

## 7.11 Limitations

* Single-level ellipses are supported; nested ellipses require careful template structure.
* No procedural macros; only declarative `syntax-rules` style.
* Scope hygiene uses marking (not alpha-renaming), which is sufficient for the supported subset.

## 7.12 Examples

### 7.12.1 `and`

```lisp
(define-syntax and
  (syntax-rules ()
    ((and) #t)
    ((and x) x)
    ((and x y ...) (if x (and y ...) #f))))
```

### 7.12.2 `or`

```lisp
(define-syntax or
  (syntax-rules ()
    ((or) #f)
    ((or x) x)
    ((or x y ...) (if x x (or y ...))))
```

### 7.12.3 `when` / `unless`

```lisp
(define-syntax when
  (syntax-rules ()
    ((when test body ...) (if test (begin body ...) nil))))

(define-syntax unless
  (syntax-rules ()
    ((unless test body ...) (if test nil (begin body ...)))))
```
